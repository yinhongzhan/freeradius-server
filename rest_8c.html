<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FreeRADIUS: /home/pjm3/freeradius-server/src/modules/rlm_rest/rest.c File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeRADIUS
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_6054e169f0f58ec6883eae51771d7f33.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_4cc3e6fe4b61867fd806af76a262971e.html">modules</a>      </li>
      <li class="navelem"><a class="el" href="dir_9a6f69099da8e4b2c74a1d96056f8454.html">rlm_rest</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">rest.c File Reference</div>  </div>
</div>
<div class="contents">

<p>Functions and datatypes for the REST (HTTP) transport.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;freeradius-devel/ident.h&gt;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &lt;ctype.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;curl/curl.h&gt;</code><br/>
<code>#include &lt;json/json.h&gt;</code><br/>
<code>#include &lt;freeradius-devel/radiusd.h&gt;</code><br/>
<code>#include &lt;freeradius-devel/libradius.h&gt;</code><br/>
<code>#include &lt;freeradius-devel/connection.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="rest_8h_source.html">rest.h</a>&quot;</code><br/>
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for rest.c:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="rest_8c__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div>
<p><a href="rest_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjson__flags.html">json_flags</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to control the conversion of JSON values to VALUE_PAIRs.  <a href="structjson__flags.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a69d79dbb506da186a157096c8cd16a5a">CURLOPT_TLSAUTH_SRP</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a71a1fde704d583a1f5dc57f77f1e957b">CURLAUTH_BASIC</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#ae8273f5a281c589c89d0d3ab2f565a93">CURLAUTH_DIGEST</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a35dfbbf1be296636005ebb30f70ca4ee">CURLAUTH_DIGEST_IE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#abd8249802f5605e95c6fedcaf22f9f5c">CURLAUTH_GSSNEGOTIATE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#ab0e8299ededa678028a9e5796b0f77ce">CURLAUTH_NTLM</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#abc73006227ef9c2827f26b33d7cbadce">CURLAUTH_NTLM_WB</a>&#160;&#160;&#160;0</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structjson__flags.html">json_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a9625f898b57b0cf16d0af5041e1d37f0">json_flags_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to control the conversion of JSON values to VALUE_PAIRs.  <a href="#a9625f898b57b0cf16d0af5041e1d37f0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#af9d6c0d1b81049f9b15e3eaefeb7f4d3">rest_init</a> (<a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *instance)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises libcurl.  <a href="#af9d6c0d1b81049f9b15e3eaefeb7f4d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#ad7843e88d39eab69006b7d59942e7fa8">rest_cleanup</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up after libcurl.  <a href="#ad7843e88d39eab69006b7d59942e7fa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a42b9e597858032b32706c7e6d9b730b4">rest_socket_create</a> (void *instance)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new connection handle for use by the FR connection API.  <a href="#a42b9e597858032b32706c7e6d9b730b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a1734ced67b5fc48a1e470cccd293335f">rest_socket_alive</a> (void *instance, void *<a class="el" href="tncs__connect_8c.html#a6b889df921fda124be06a946b9414194">handle</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the last TCP socket associated with a handle is still active.  <a href="#a1734ced67b5fc48a1e470cccd293335f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a2150b941de48b3f602439dd80aae1811">rest_socket_delete</a> (UNUSED void *instance, void *<a class="el" href="tncs__connect_8c.html#a6b889df921fda124be06a946b9414194">handle</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a libcurl handle, and any additional memory used by context data.  <a href="#a2150b941de48b3f602439dd80aae1811"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#ab434441f64355ba1c46cd4ed51e45425">rest_encode_post</a> (void *ptr, size_t size, size_t nmemb, void *userdata)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes VALUE_PAIR linked list in POST format.  <a href="#ab434441f64355ba1c46cd4ed51e45425"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a3cf8d055c2f101567cf335ad58c2d7e7">rest_encode_json</a> (void *ptr, size_t size, size_t nmemb, void *userdata)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes VALUE_PAIR linked list in JSON format.  <a href="#a3cf8d055c2f101567cf335ad58c2d7e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#ab71f5bb4f3ea89aa873fbd7e137e556b">rest_read_wrapper</a> (char **buffer, <a class="el" href="rest_8h.html#a754712d2e6f1ae5cc9d701345aadf1f3">rest_read_t</a> func, size_t limit, void *userdata)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emulates successive libcurl calls to an encoding function.  <a href="#ab71f5bb4f3ea89aa873fbd7e137e556b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a2d6e909e03e0aaab912cf82ca19ba0c6">rest_read_ctx_init</a> (<a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *request, <a class="el" href="structrlm__rest__read__t.html">rlm_rest_read_t</a> *ctx, boolean sort)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">(Re-)Initialises the data in a <a class="el" href="structrlm__rest__read__t.html">rlm_rest_read_t</a>.  <a href="#a2d6e909e03e0aaab912cf82ca19ba0c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a88e265303baa86e23e2b95d3f9f2bf45">rest_read_ctx_free</a> (<a class="el" href="structrlm__rest__read__t.html">rlm_rest_read_t</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the VALUE_PAIR array created by rest_read_ctx_init.  <a href="#a88e265303baa86e23e2b95d3f9f2bf45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a0da81f96a416a6b7b63b5a402c98e309">rest_check_truncation</a> (<a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *request, const char *raw, <a class="el" href="libradius_8h.html#a698dfbdbe21ffce4eeca03517282c498">VALUE_PAIR</a> *vp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that value wasn't truncated when it was converted to a VALUE_PAIR.  <a href="#a0da81f96a416a6b7b63b5a402c98e309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a8ac753a6a37bc35d8e06f9bfe17e7fdc">rest_decode_post</a> (<a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *instance, UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *section, <a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *request, void *<a class="el" href="tncs__connect_8c.html#a6b889df921fda124be06a946b9414194">handle</a>, char *raw, UNUSED size_t rawlen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts POST response into VALUE_PAIRs and adds them to the request.  <a href="#a8ac753a6a37bc35d8e06f9bfe17e7fdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="libradius_8h.html#a698dfbdbe21ffce4eeca03517282c498">VALUE_PAIR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#acb0aeb0572988634723a72ae1f4b1a13">json_pairmake_leaf</a> (<a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *instance, UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *section, <a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *request, const <a class="el" href="libradius_8h.html#ae4ddbbc6695d922e7e54da5533132806">DICT_ATTR</a> *da, <a class="el" href="rest_8c.html#a9625f898b57b0cf16d0af5041e1d37f0">json_flags_t</a> *flags, json_object *leaf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts JSON "value" key into VALUE_PAIR.  <a href="#acb0aeb0572988634723a72ae1f4b1a13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="libradius_8h.html#a698dfbdbe21ffce4eeca03517282c498">VALUE_PAIR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#ae070013a304fa7beb599179c595279cb">json_pairmake</a> (<a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *instance, UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *section, <a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *request, json_object *object, int level, int *max_attrs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes JSON response and converts it into multiple VALUE_PAIRs.  <a href="#ae070013a304fa7beb599179c595279cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a8ad2c9225b5020dc8007e464687fb602">rest_decode_json</a> (<a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *instance, UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *section, UNUSED <a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *request, UNUSED void *<a class="el" href="tncs__connect_8c.html#a6b889df921fda124be06a946b9414194">handle</a>, char *raw, UNUSED size_t rawlen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts JSON response into VALUE_PAIRs and adds them to the request.  <a href="#a8ad2c9225b5020dc8007e464687fb602"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a88deee0c267cfc5af2ce96265faf2fa8">rest_write_header</a> (void *ptr, size_t size, size_t nmemb, void *userdata)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes incoming HTTP header data from libcurl.  <a href="#a88deee0c267cfc5af2ce96265faf2fa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#ad31b21480350ba053bfdb924b54432b5">rest_write_body</a> (void *ptr, size_t size, size_t nmemb, void *userdata)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes incoming HTTP body data from libcurl.  <a href="#ad31b21480350ba053bfdb924b54432b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a1d7816f2d318565786021817aeba101f">rest_write_ctx_init</a> (<a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *request, <a class="el" href="structrlm__rest__write__t.html">rlm_rest_write_t</a> *ctx, <a class="el" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43">http_body_type_t</a> type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">(Re-)Initialises the data in a <a class="el" href="structrlm__rest__write__t.html">rlm_rest_write_t</a>.  <a href="#a1d7816f2d318565786021817aeba101f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a0dd236900db73e09b33522d2a1af54b1">rest_write_free</a> (<a class="el" href="structrlm__rest__write__t.html">rlm_rest_write_t</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the intermediary buffer created by rest_write.  <a href="#a0dd236900db73e09b33522d2a1af54b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a961fe2c1327442f08fd9c491fff5d2a6">rest_request_config_body</a> (<a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *instance, <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *section, <a class="el" href="structrlm__rest__handle__t.html">rlm_rest_handle_t</a> *<a class="el" href="tncs__connect_8c.html#a6b889df921fda124be06a946b9414194">handle</a>, <a class="el" href="rest_8h.html#a754712d2e6f1ae5cc9d701345aadf1f3">rest_read_t</a> func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures body specific curlopts.  <a href="#a961fe2c1327442f08fd9c491fff5d2a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a0dd98f402cb3c570232c61ec6a8ba6ce">rest_request_config</a> (<a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *instance, <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *section, <a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *request, void *<a class="el" href="tncs__connect_8c.html#a6b889df921fda124be06a946b9414194">handle</a>, <a class="el" href="rest_8h.html#a2fd930fba66817097e73ba9b75800eb2">http_method_t</a> method, <a class="el" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43">http_body_type_t</a> type, char *uri)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures request curlopts.  <a href="#a0dd98f402cb3c570232c61ec6a8ba6ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a6d395c046112ff5745d535ab31bc64b5">rest_request_perform</a> (<a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *instance, UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *section, void *<a class="el" href="tncs__connect_8c.html#a6b889df921fda124be06a946b9414194">handle</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a REST (HTTP) request.  <a href="#a6d395c046112ff5745d535ab31bc64b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a7851d0bf044e4a74fdb396e18d940f8d">rest_request_decode</a> (<a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *instance, UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *section, <a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *request, void *<a class="el" href="tncs__connect_8c.html#a6b889df921fda124be06a946b9414194">handle</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the response to the correct decode function.  <a href="#a7851d0bf044e4a74fdb396e18d940f8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a7cd8299f0a41eca8b3475c9f0cb1c625">rest_request_cleanup</a> (UNUSED <a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *instance, UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *section, void *<a class="el" href="tncs__connect_8c.html#a6b889df921fda124be06a946b9414194">handle</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up after a REST request.  <a href="#a7cd8299f0a41eca8b3475c9f0cb1c625"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a243cd41d83240b6e52cf7e170785a1af">rest_uri_escape</a> (char *out, size_t outlen, const char *raw)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">URL encodes a string.  <a href="#a243cd41d83240b6e52cf7e170785a1af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a2762ce07f4a9e3fbd5ed9d5815c42fd4">rest_uri_build</a> (<a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *instance, <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *section, <a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *request, char *buffer, size_t bufsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds URI; performs XLAT expansions and encoding.  <a href="#a2762ce07f4a9e3fbd5ed9d5815c42fd4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43">http_body_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#ab429e4b10850d1e40766e0aa58316c9b">http_body_type_supported</a> [HTTP_BODY_NUM_ENTRIES]</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of encoder/decoder support.  <a href="#ab429e4b10850d1e40766e0aa58316c9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43">http_body_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a464926ec2ef2e24d5b7da3691b8398f6">http_curl_auth</a> [HTTP_AUTH_NUM_ENTRIES]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structFR__NAME__NUMBER.html">FR_NAME_NUMBER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a8dc21ec6893fd93311316d23e446347b">http_method_table</a> []</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion table for method config values.  <a href="#a8dc21ec6893fd93311316d23e446347b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structFR__NAME__NUMBER.html">FR_NAME_NUMBER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#ad34138dc5bcd567ef2c520ef721c8ac2">http_body_type_table</a> []</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion table for type config values.  <a href="#ad34138dc5bcd567ef2c520ef721c8ac2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structFR__NAME__NUMBER.html">FR_NAME_NUMBER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#ae9d58a7026dcc3f6e7e9a7c608f088cf">http_auth_table</a> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structFR__NAME__NUMBER.html">FR_NAME_NUMBER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rest_8c.html#a66f9f5e6959f072ef736c9c2bb86b25b">http_content_type_table</a> []</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion table for "Content-Type" header values.  <a href="#a66f9f5e6959f072ef736c9c2bb86b25b"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Functions and datatypes for the REST (HTTP) transport. </p>
<p>Version: $Id$</p>
<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA</p>
<p>Copyright 2012 Arran Cudbard-Bell &lt;<a href="mailto:a.cudbard-bell@freeradius.org">a.cudbard-bell@freeradius.org</a>&gt; </p>

<p>Definition in file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a71a1fde704d583a1f5dc57f77f1e957b"></a><!-- doxytag: member="rest.c::CURLAUTH_BASIC" ref="a71a1fde704d583a1f5dc57f77f1e957b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CURLAUTH_BASIC&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="rest_8c_source.html#l00067">67</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae8273f5a281c589c89d0d3ab2f565a93"></a><!-- doxytag: member="rest.c::CURLAUTH_DIGEST" ref="ae8273f5a281c589c89d0d3ab2f565a93" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CURLAUTH_DIGEST&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="rest_8c_source.html#l00070">70</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a35dfbbf1be296636005ebb30f70ca4ee"></a><!-- doxytag: member="rest.c::CURLAUTH_DIGEST_IE" ref="a35dfbbf1be296636005ebb30f70ca4ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CURLAUTH_DIGEST_IE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="rest_8c_source.html#l00073">73</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="abd8249802f5605e95c6fedcaf22f9f5c"></a><!-- doxytag: member="rest.c::CURLAUTH_GSSNEGOTIATE" ref="abd8249802f5605e95c6fedcaf22f9f5c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CURLAUTH_GSSNEGOTIATE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="rest_8c_source.html#l00076">76</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="ab0e8299ededa678028a9e5796b0f77ce"></a><!-- doxytag: member="rest.c::CURLAUTH_NTLM" ref="ab0e8299ededa678028a9e5796b0f77ce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CURLAUTH_NTLM&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="rest_8c_source.html#l00079">79</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="abc73006227ef9c2827f26b33d7cbadce"></a><!-- doxytag: member="rest.c::CURLAUTH_NTLM_WB" ref="abc73006227ef9c2827f26b33d7cbadce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CURLAUTH_NTLM_WB&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="rest_8c_source.html#l00082">82</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a69d79dbb506da186a157096c8cd16a5a"></a><!-- doxytag: member="rest.c::CURLOPT_TLSAUTH_SRP" ref="a69d79dbb506da186a157096c8cd16a5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CURLOPT_TLSAUTH_SRP&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="rest_8c_source.html#l00064">64</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a9625f898b57b0cf16d0af5041e1d37f0"></a><!-- doxytag: member="rest.c::json_flags_t" ref="a9625f898b57b0cf16d0af5041e1d37f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structjson__flags.html">json_flags</a>  <a class="el" href="rest_8c.html#a9625f898b57b0cf16d0af5041e1d37f0">json_flags_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flags to control the conversion of JSON values to VALUE_PAIRs. </p>
<p>These fields are set when parsing the expanded format for value pairs in JSON, and control how json_pairmake_leaf and json_pairmake convert the JSON value, and move the new VALUE_PAIR into an attribute list.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rest_8c.html#ae070013a304fa7beb599179c595279cb" title="Processes JSON response and converts it into multiple VALUE_PAIRs.">json_pairmake</a> </dd>
<dd>
<a class="el" href="rest_8c.html#acb0aeb0572988634723a72ae1f4b1a13" title="Converts JSON &quot;value&quot; key into VALUE_PAIR.">json_pairmake_leaf</a> </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae070013a304fa7beb599179c595279cb"></a><!-- doxytag: member="rest.c::json_pairmake" ref="ae070013a304fa7beb599179c595279cb" args="(rlm_rest_t *instance, UNUSED rlm_rest_section_t *section, REQUEST *request, json_object *object, int level, int *max_attrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="libradius_8h.html#a698dfbdbe21ffce4eeca03517282c498">VALUE_PAIR</a>* json_pairmake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">json_object *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>max_attrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Processes JSON response and converts it into multiple VALUE_PAIRs. </p>
<p>Processes JSON attribute declarations in the format below. Will recurse when processing nested attributes. When processing nested attributes flags and operators from previous attributes are not inherited.</p>
<p>JSON response format is: </p>
<div class="fragment"><pre class="fragment">
{
	"&lt;attribute0&gt;":{
		do_xlat:&lt;bool&gt;,
		is_json:&lt;bool&gt;,
		"op":"&lt;operator&gt;",
		"value":[&lt;value0&gt;,&lt;value1&gt;,&lt;valueN&gt;]
	},
	"&lt;attribute1&gt;":{
		"value":{
			"&lt;nested-attribute0&gt;":{
				"op":"&lt;operator&gt;",
				"value":&lt;value0&gt;
			}
		}
	},
	"&lt;attribute2&gt;":"&lt;value0&gt;",
	"&lt;attributeN&gt;":"[&lt;value0&gt;,&lt;value1&gt;,&lt;valueN&gt;]"
}
</pre></div><p>JSON valuepair flags (bools):</p>
<ul>
<li>do_xlat (optional) Controls xlat expansion of values. Defaults to TRUE.</li>
<li>is_json (optional) If TRUE, any nested JSON data will be copied to the VALUE_PAIR in string form. Defaults to TRUE.</li>
<li>op (optional) Controls how the attribute is inserted into the target list. Defaults to ':=' (T_OP_SET).</li>
</ul>
<p>If "op" is ':=' or '=', it will be automagically changed to '+=' for the second and subsequent values in multivalued attributes. This does not work between multiple attribute declarations.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="token_8c.html#a8387db2591785802f9a75f81da5430f3">fr_tokens</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Current request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>containing root node, or parent node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Current nesting level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_attrs</td><td>counter, decremented after each VALUE_PAIR is created, when 0 no more attributes will be processed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>VALUE_PAIR or NULL on error. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l01248">1248</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="acb0aeb0572988634723a72ae1f4b1a13"></a><!-- doxytag: member="rest.c::json_pairmake_leaf" ref="acb0aeb0572988634723a72ae1f4b1a13" args="(rlm_rest_t *instance, UNUSED rlm_rest_section_t *section, REQUEST *request, const DICT_ATTR *da, json_flags_t *flags, json_object *leaf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="libradius_8h.html#a698dfbdbe21ffce4eeca03517282c498">VALUE_PAIR</a>* json_pairmake_leaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libradius_8h.html#ae4ddbbc6695d922e7e54da5533132806">DICT_ATTR</a> *&#160;</td>
          <td class="paramname"><em>da</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rest_8c.html#a9625f898b57b0cf16d0af5041e1d37f0">json_flags_t</a> *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">json_object *&#160;</td>
          <td class="paramname"><em>leaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts JSON "value" key into VALUE_PAIR. </p>
<p>If leaf is not in fact a leaf node, but contains JSON data, the data will written to the attribute in JSON string format.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Current request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute</td><td>name without qualifiers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>containing the operator other flags controlling value expansion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leaf</td><td>object containing the VALUE_PAIR value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The VALUE_PAIR just created, or NULL on error. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l01154">1154</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0da81f96a416a6b7b63b5a402c98e309"></a><!-- doxytag: member="rest.c::rest_check_truncation" ref="a0da81f96a416a6b7b63b5a402c98e309" args="(REQUEST *request, const char *raw, VALUE_PAIR *vp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void rest_check_truncation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libradius_8h.html#a698dfbdbe21ffce4eeca03517282c498">VALUE_PAIR</a> *&#160;</td>
          <td class="paramname"><em>vp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Verify that value wasn't truncated when it was converted to a VALUE_PAIR. </p>
<p>Certain values may be truncated when they're converted into VALUE_PAIRs for example 64bit integers converted to 32bit integers. Warn the user when this happens.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">raw</td><td>string from decoder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vp</td><td>containing parsed value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00933">933</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad7843e88d39eab69006b7d59942e7fa8"></a><!-- doxytag: member="rest.c::rest_cleanup" ref="ad7843e88d39eab69006b7d59942e7fa8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rest_cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleans up after libcurl. </p>
<p>Wrapper around curl_global_cleanup, frees any memory allocated by rest_init. Must only be called once per call of rest_init.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rest_8h.html#af9d6c0d1b81049f9b15e3eaefeb7f4d3" title="Initialises libcurl.">rest_init</a> </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00242">242</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a8ad2c9225b5020dc8007e464687fb602"></a><!-- doxytag: member="rest.c::rest_decode_json" ref="a8ad2c9225b5020dc8007e464687fb602" args="(rlm_rest_t *instance, UNUSED rlm_rest_section_t *section, UNUSED REQUEST *request, UNUSED void *handle, char *raw, UNUSED size_t rawlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int rest_decode_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED <a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>raw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED size_t&#160;</td>
          <td class="paramname"><em>rawlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts JSON response into VALUE_PAIRs and adds them to the request. </p>
<p>Converts the raw JSON string into a json-c object tree and passes it to json_pairmake. After the tree has been parsed json_object_put is called which decrements the reference, count to the root node by one, and frees the entire tree.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rest_8c.html#a3cf8d055c2f101567cf335ad58c2d7e7" title="Encodes VALUE_PAIR linked list in JSON format.">rest_encode_json</a> </dd>
<dd>
<a class="el" href="rest_8c.html#ae070013a304fa7beb599179c595279cb" title="Processes JSON response and converts it into multiple VALUE_PAIRs.">json_pairmake</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Current request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">raw</td><td>buffer containing JSON data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rawlen</td><td>Length of data in raw buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of VALUE_PAIRs processed or -1 on unrecoverable error. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l01476">1476</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a8ac753a6a37bc35d8e06f9bfe17e7fdc"></a><!-- doxytag: member="rest.c::rest_decode_post" ref="a8ac753a6a37bc35d8e06f9bfe17e7fdc" args="(rlm_rest_t *instance, UNUSED rlm_rest_section_t *section, REQUEST *request, void *handle, char *raw, UNUSED size_t rawlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int rest_decode_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>raw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED size_t&#160;</td>
          <td class="paramname"><em>rawlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts POST response into VALUE_PAIRs and adds them to the request. </p>
<p>Accepts VALUE_PAIRS in the same format as rest_encode_post, but with the addition of optional attribute list qualifiers as part of the attribute name string.</p>
<p>If no qualifiers are specified, will default to the request list.</p>
<p>POST response format is: </p>
<div class="fragment"><pre class="fragment">[outer.][&lt;list&gt;:]&lt;attribute0&gt;=&lt;value0&gt;&amp;[outer.][&lt;list&gt;:]&lt;attribute1&gt;=&lt;value1&gt;&amp;[outer.][&lt;list&gt;:]&lt;attributeN&gt;=&lt;valueN&gt; </pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rest_8c.html#ab434441f64355ba1c46cd4ed51e45425" title="Encodes VALUE_PAIR linked list in POST format.">rest_encode_post</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td><a class="el" href="structrlm__rest__handle__t.html">rlm_rest_handle_t</a> to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Current request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">raw</td><td>buffer containing POST data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rawlen</td><td>Length of data in raw buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of VALUE_PAIRs processed or -1 on unrecoverable error. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00968">968</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3cf8d055c2f101567cf335ad58c2d7e7"></a><!-- doxytag: member="rest.c::rest_encode_json" ref="a3cf8d055c2f101567cf335ad58c2d7e7" args="(void *ptr, size_t size, size_t nmemb, void *userdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t rest_encode_json </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encodes VALUE_PAIR linked list in JSON format. </p>
<p>This is a stream function matching the rest_read_t prototype. Multiple successive calls will return additional encoded VALUE_PAIRs.</p>
<p>Only complete attribute headers </p>
<div class="fragment"><pre class="fragment">"&lt;name&gt;":{"type":"&lt;type&gt;","value":['&lt;/pre&gt; </pre></div><p> and complete attribute values will be written to ptr.</p>
<p>If an attribute occurs multiple times in the request the attribute values will be concatenated into a single value array.</p>
<p>JSON request format is: </p>
<div class="fragment"><pre class="fragment">
{
	"&lt;attribute0&gt;":{
		"type":"&lt;type0&gt;",
		"value":[&lt;value0&gt;,&lt;value1&gt;,&lt;valueN&gt;]
	},
	"&lt;attribute1&gt;":{
		"type":"&lt;type1&gt;",
		"value":[...]
	},
	"&lt;attributeN&gt;":{
		"type":"&lt;typeN&gt;",
		"value":[...]
	},
}
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr</td><td>Char buffer to write encoded data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Multiply by nmemb to get the length of ptr. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nmemb</td><td>Multiply by size to get the length of ptr. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td><a class="el" href="structrlm__rest__read__t.html">rlm_rest_read_t</a> to keep encoding state between calls. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>length of data (including NULL) written to ptr, or 0 if no more data to write. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00609">609</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="ab434441f64355ba1c46cd4ed51e45425"></a><!-- doxytag: member="rest.c::rest_encode_post" ref="ab434441f64355ba1c46cd4ed51e45425" args="(void *ptr, size_t size, size_t nmemb, void *userdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t rest_encode_post </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encodes VALUE_PAIR linked list in POST format. </p>
<p>This is a stream function matching the rest_read_t prototype. Multiple successive calls will return additional encoded VALUE_PAIRs. Only complete attribute headers </p>
<div class="fragment"><pre class="fragment">'&lt;name&gt;=' </pre></div><p> and values will be written to the ptr buffer.</p>
<p>POST request format is: </p>
<div class="fragment"><pre class="fragment">&lt;attribute0&gt;=&lt;value0&gt;&amp;&lt;attribute1&gt;=&lt;value1&gt;&amp;&lt;attributeN&gt;=&lt;valueN&gt;</pre></div><p>All attributes and values are url encoded. There is currently no support for nested attributes, or attribute qualifiers.</p>
<p>Nested attributes may be added in the future using </p>
<div class="fragment"><pre class="fragment">&lt;attribute-outer&gt;:&lt;attribute-inner&gt;</pre></div><p> to denotate nesting.</p>
<p>Requires libcurl for url encoding.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rest_8c.html#a8ac753a6a37bc35d8e06f9bfe17e7fdc" title="Converts POST response into VALUE_PAIRs and adds them to the request.">rest_decode_post</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr</td><td>Char buffer to write encoded data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Multiply by nmemb to get the length of ptr. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nmemb</td><td>Multiply by size to get the length of ptr. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td><a class="el" href="structrlm__rest__read__t.html">rlm_rest_read_t</a> to keep encoding state between calls. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>length of data (including NULL) written to ptr, or 0 if no more data to write. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00442">442</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="af9d6c0d1b81049f9b15e3eaefeb7f4d3"></a><!-- doxytag: member="rest.c::rest_init" ref="af9d6c0d1b81049f9b15e3eaefeb7f4d3" args="(rlm_rest_t *instance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rest_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialises libcurl. </p>
<p>Allocates global variables and memory required for libcurl to fundtion. MUST only be called once per module instance.</p>
<p>rest_cleanup must not be called if rest_init fails.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rest_8h.html#ad7843e88d39eab69006b7d59942e7fa8" title="Cleans up after libcurl.">rest_cleanup</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if init succeeded FALSE if it failed. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00213">213</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a88e265303baa86e23e2b95d3f9f2bf45"></a><!-- doxytag: member="rest.c::rest_read_ctx_free" ref="a88e265303baa86e23e2b95d3f9f2bf45" args="(rlm_rest_read_t *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void rest_read_ctx_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrlm__rest__read__t.html">rlm_rest_read_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees the VALUE_PAIR array created by rest_read_ctx_init. </p>
<p>Must be called between encoding sessions else module will leak VALUE_PAIR pointers.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rest_8c.html#a2d6e909e03e0aaab912cf82ca19ba0c6" title="(Re-)Initialises the data in a rlm_rest_read_t.">rest_read_ctx_init</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">read</td><td>to free. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00917">917</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2d6e909e03e0aaab912cf82ca19ba0c6"></a><!-- doxytag: member="rest.c::rest_read_ctx_init" ref="a2d6e909e03e0aaab912cf82ca19ba0c6" args="(REQUEST *request, rlm_rest_read_t *ctx, boolean sort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void rest_read_ctx_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrlm__rest__read__t.html">rlm_rest_read_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>sort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(Re-)Initialises the data in a <a class="el" href="structrlm__rest__read__t.html">rlm_rest_read_t</a>. </p>
<p>Resets the values of a <a class="el" href="structrlm__rest__read__t.html">rlm_rest_read_t</a> to their defaults.</p>
<p>Must be called between encoding sessions.</p>
<p>As part of initialisation all VALUE_PAIR pointers in the REQUEST packet are written to an array.</p>
<p>If sort is TRUE, this array of VALUE_PAIR pointers will be sorted by vendor and then by attribute. This is for stream encoders which may concatenate multiple attribute values together into an array.</p>
<p>After the encoding session has completed this array must be freed by calling rest_read_ctx_free .</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rest_8c.html#a88e265303baa86e23e2b95d3f9f2bf45" title="Frees the VALUE_PAIR array created by rest_read_ctx_init.">rest_read_ctx_free</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Current request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read</td><td>to initialise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sort</td><td>If TRUE VALUE_PAIRs will be sorted within the VALUE_PAIR pointer array. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00851">851</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="ab71f5bb4f3ea89aa873fbd7e137e556b"></a><!-- doxytag: member="rest.c::rest_read_wrapper" ref="ab71f5bb4f3ea89aa873fbd7e137e556b" args="(char **buffer, rest_read_t func, size_t limit, void *userdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t rest_read_wrapper </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rest_8h.html#a754712d2e6f1ae5cc9d701345aadf1f3">rest_read_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emulates successive libcurl calls to an encoding function. </p>
<p>This function is used when the request will be sent to the HTTP server as one contiguous entity. A buffer of REST_BODY_INCR bytes is allocated and passed to the stream encoding function.</p>
<p>If the stream function does not return 0, a new buffer is allocated which is the size of the previous buffer + REST_BODY_INCR bytes, the data from the previous buffer is copied, and freed, and another call is made to the stream function, passing a pointer into the new buffer at the end of the previously written data.</p>
<p>This process continues until the stream function signals (by returning 0) that it has no more data to write.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>where the pointer to the malloced buffer should be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Stream function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>Maximum buffer size to alloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td><a class="el" href="structrlm__rest__read__t.html">rlm_rest_read_t</a> to keep encoding state between calls to stream function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the length of the data written to the buffer (excluding NULL) or -1 if alloc &gt;= limit. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00794">794</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7cd8299f0a41eca8b3475c9f0cb1c625"></a><!-- doxytag: member="rest.c::rest_request_cleanup" ref="a7cd8299f0a41eca8b3475c9f0cb1c625" args="(UNUSED rlm_rest_t *instance, UNUSED rlm_rest_section_t *section, void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rest_request_cleanup </td>
          <td>(</td>
          <td class="paramtype">UNUSED <a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleans up after a REST request. </p>
<p>Resets all options associated with a CURL handle, and frees any headers associated with it.</p>
<p>Calls rest_read_ctx_free and rest_write_free to free any memory used by context data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>to cleanup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success or FALSE on error. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l02280">2280</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0dd98f402cb3c570232c61ec6a8ba6ce"></a><!-- doxytag: member="rest.c::rest_request_config" ref="a0dd98f402cb3c570232c61ec6a8ba6ce" args="(rlm_rest_t *instance, rlm_rest_section_t *section, REQUEST *request, void *handle, http_method_t method, http_body_type_t type, char *uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rest_request_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rest_8h.html#a2fd930fba66817097e73ba9b75800eb2">http_method_t</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43">http_body_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>uri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures request curlopts. </p>
<p>Configures libcurl handle setting various curlopts for things like local client time, Content-Type, and other FreeRADIUS custom headers.</p>
<p>Current FreeRADIUS custom headers are:</p>
<ul>
<li>X-FreeRADIUS-Section The module section being processed.</li>
<li>X-FreeRADIUS-Server The current virtual server the REQUEST is passing through.</li>
</ul>
<p>Sets up callbacks for all response processing (buffers and body data).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>to configure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Current request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>to use (HTTP verbs PUT, POST, DELETE etc...). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Content-Type for request encoding, also sets the default for decoding. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uri</td><td>buffer containing the expanded URI to send the request to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success (all opts configured) FALSE on error. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l01872">1872</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a961fe2c1327442f08fd9c491fff5d2a6"></a><!-- doxytag: member="rest.c::rest_request_config_body" ref="a961fe2c1327442f08fd9c491fff5d2a6" args="(rlm_rest_t *instance, rlm_rest_section_t *section, rlm_rest_handle_t *handle, rest_read_t func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int rest_request_config_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrlm__rest__handle__t.html">rlm_rest_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rest_8h.html#a754712d2e6f1ae5cc9d701345aadf1f3">rest_read_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures body specific curlopts. </p>
<p>Configures libcurl handle to use either chunked mode, where the request data will be sent using multiple HTTP requests, or contiguous mode where the request data will be sent in a single HTTP request.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td><a class="el" href="structrlm__rest__handle__t.html">rlm_rest_handle_t</a> to configure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>to pass to libcurl for chunked. transfers (NULL if not using chunked mode). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success FALSE on error. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l01804">1804</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7851d0bf044e4a74fdb396e18d940f8d"></a><!-- doxytag: member="rest.c::rest_request_decode" ref="a7851d0bf044e4a74fdb396e18d940f8d" args="(rlm_rest_t *instance, UNUSED rlm_rest_section_t *section, REQUEST *request, void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rest_request_decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends the response to the correct decode function. </p>
<p>Uses the Content-Type information written in rest_write_header to determine the correct decode function to use. The decode function will then convert the raw received data into VALUE_PAIRs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Current request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success or FALSE on error. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l02226">2226</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6d395c046112ff5745d535ab31bc64b5"></a><!-- doxytag: member="rest.c::rest_request_perform" ref="a6d395c046112ff5745d535ab31bc64b5" args="(rlm_rest_t *instance, UNUSED rlm_rest_section_t *section, void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rest_request_perform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED <a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a REST (HTTP) request. </p>
<p>Send the actual REST request to the server. The response will be handled by the numerous callbacks configured in rest_request_config.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success or FALSE on error. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l02197">2197</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a1734ced67b5fc48a1e470cccd293335f"></a><!-- doxytag: member="rest.c::rest_socket_alive" ref="a1734ced67b5fc48a1e470cccd293335f" args="(void *instance, void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rest_socket_alive </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Verifies that the last TCP socket associated with a handle is still active. </p>
<p>Quieries libcurl to try and determine if the TCP socket associated with a connection handle is still viable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE if the last socket is dead, or if the socket state couldn't be determined, else TRUE. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00369">369</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a42b9e597858032b32706c7e6d9b730b4"></a><!-- doxytag: member="rest.c::rest_socket_create" ref="a42b9e597858032b32706c7e6d9b730b4" args="(void *instance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rest_socket_create </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new connection handle for use by the FR connection API. </p>
<p>Matches the fr_connection_create_t function prototype, is passed to fr_connection_pool_init, and called when a new connection is required by the connection pool API.</p>
<p>Creates an instances of <a class="el" href="structrlm__rest__handle__t.html">rlm_rest_handle_t</a>, and <a class="el" href="structrlm__rest__curl__context__t.html">rlm_rest_curl_context_t</a> which hold the context data required for generating requests and parsing responses. Calling rest_socket_delete will free this memory.</p>
<p>If instance-&gt;connect_uri is not NULL libcurl will attempt to open a TCP socket to the server specified in the URI. This is done so that when the socket is first used, there will already be a cached TCP connection to the REST server associated with the curl handle.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rest_8h.html#a88d29c009992f1fb5342ff90f12117ea">rest_socket_delete</a> </dd>
<dd>
<a class="el" href="connection_8c.html#adaddec7ab09899dfdaee3e30594ad9a6">fr_connection_pool_init</a> </dd>
<dd>
<a class="el" href="connection_8h.html#ad4910e355c62e2058766f7b288474d9b">fr_connection_create_t</a> </dd>
<dd>
<a class="el" href="connection_8c.html" title="Handle pools of connections (threads, sockets, etc.)">connection.c</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>connection handle or NULL if the connection failed or couldn't be initialised. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00271">271</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2150b941de48b3f602439dd80aae1811"></a><!-- doxytag: member="rest.c::rest_socket_delete" ref="a2150b941de48b3f602439dd80aae1811" args="(UNUSED void *instance, void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rest_socket_delete </td>
          <td>(</td>
          <td class="paramtype">UNUSED void *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a libcurl handle, and any additional memory used by context data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td><a class="el" href="structrlm__rest__handle__t.html">rlm_rest_handle_t</a> to close and free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns TRUE. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00401">401</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2762ce07f4a9e3fbd5ed9d5815c42fd4"></a><!-- doxytag: member="rest.c::rest_uri_build" ref="a2762ce07f4a9e3fbd5ed9d5815c42fd4" args="(rlm_rest_t *instance, rlm_rest_section_t *section, REQUEST *request, char *buffer, size_t bufsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rest_uri_build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrlm__rest__t.html">rlm_rest_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrlm__rest__section__t.html">rlm_rest_section_t</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds URI; performs XLAT expansions and encoding. </p>
<p>Splits the URI into "http://example.org" and "/%{xlat}/query/?bar=foo" Both components are expanded, but values expanded for the second component are also url encoded.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>configuration data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Current request </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>to write expanded URI to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>Size of buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>length of data written to buffer (excluding NULL) or &lt; 0 if an error occurred. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l02346">2346</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a243cd41d83240b6e52cf7e170785a1af"></a><!-- doxytag: member="rest.c::rest_uri_escape" ref="a243cd41d83240b6e52cf7e170785a1af" args="(char *out, size_t outlen, const char *raw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t rest_uri_escape </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>URL encodes a string. </p>
<p>Encode special chars as per RFC 3986 section 4.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Where to write escaped string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outlen</td><td>Size of out buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">raw</td><td>string to be urlencoded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>length of data written to out (excluding NULL). </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l02321">2321</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad31b21480350ba053bfdb924b54432b5"></a><!-- doxytag: member="rest.c::rest_write_body" ref="ad31b21480350ba053bfdb924b54432b5" args="(void *ptr, size_t size, size_t nmemb, void *userdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t rest_write_body </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Processes incoming HTTP body data from libcurl. </p>
<p>Writes incoming body data to an intermediary buffer for later parsing by one of the decode functions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Char buffer where inbound header data is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Multiply by nmemb to get the length of ptr. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nmemb</td><td>Multiply by size to get the length of ptr. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td><a class="el" href="structrlm__rest__write__t.html">rlm_rest_write_t</a> to keep parsing state between calls. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>length of data processed, or 0 on error. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l01698">1698</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a1d7816f2d318565786021817aeba101f"></a><!-- doxytag: member="rest.c::rest_write_ctx_init" ref="a1d7816f2d318565786021817aeba101f" args="(REQUEST *request, rlm_rest_write_t *ctx, http_body_type_t type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void rest_write_ctx_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="radiusd_8h.html#a5a6597abc105bb9f7f9bce5bad2f87b1">REQUEST</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrlm__rest__write__t.html">rlm_rest_write_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43">http_body_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(Re-)Initialises the data in a <a class="el" href="structrlm__rest__write__t.html">rlm_rest_write_t</a>. </p>
<p>This resets the values of the a <a class="el" href="structrlm__rest__write__t.html">rlm_rest_write_t</a> to their defaults. Must be called between encoding sessions.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rest_8c.html#ad31b21480350ba053bfdb924b54432b5" title="Processes incoming HTTP body data from libcurl.">rest_write_body</a> </dd>
<dd>
<a class="el" href="rest_8c.html#a88deee0c267cfc5af2ce96265faf2fa8" title="Processes incoming HTTP header data from libcurl.">rest_write_header</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Current request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>to initialise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Default http_body_type to use when decoding raw data, may be overwritten by rest_write_header. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l01769">1769</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0dd236900db73e09b33522d2a1af54b1"></a><!-- doxytag: member="rest.c::rest_write_free" ref="a0dd236900db73e09b33522d2a1af54b1" args="(rlm_rest_write_t *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void rest_write_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrlm__rest__write__t.html">rlm_rest_write_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees the intermediary buffer created by rest_write. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>to be freed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l01784">1784</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a88deee0c267cfc5af2ce96265faf2fa8"></a><!-- doxytag: member="rest.c::rest_write_header" ref="a88deee0c267cfc5af2ce96265faf2fa8" args="(void *ptr, size_t size, size_t nmemb, void *userdata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t rest_write_header </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Processes incoming HTTP header data from libcurl. </p>
<p>Processes the status line, and Content-Type headers from the incoming HTTP response.</p>
<p>Matches prototype for CURLOPT_HEADERFUNCTION, and will be called directly by libcurl.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Char buffer where inbound header data is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Multiply by nmemb to get the length of ptr. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nmemb</td><td>Multiply by size to get the length of ptr. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td><a class="el" href="structrlm__rest__write__t.html">rlm_rest_write_t</a> to keep parsing state between calls. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Length of data processed, or 0 on error. </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l01525">1525</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ae9d58a7026dcc3f6e7e9a7c608f088cf"></a><!-- doxytag: member="rest.c::http_auth_table" ref="ae9d58a7026dcc3f6e7e9a7c608f088cf" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structFR__NAME__NUMBER.html">FR_NAME_NUMBER</a> <a class="el" href="rest_8h.html#ae9d58a7026dcc3f6e7e9a7c608f088cf">http_auth_table</a>[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        { <span class="stringliteral">&quot;none&quot;</span>,               <a class="code" href="rest_8h.html#ad18ce766db31fff3efc1896156647fa5a208f0926853b84d7acf3ce0669e9dc1c">HTTP_AUTH_NONE</a>          },
        { <span class="stringliteral">&quot;srp&quot;</span>,                <a class="code" href="rest_8h.html#ad18ce766db31fff3efc1896156647fa5a752ceaf5e18fd71ccab046068141706c">HTTP_AUTH_TLS_SRP</a>       },
        { <span class="stringliteral">&quot;basic&quot;</span>,              <a class="code" href="rest_8h.html#ad18ce766db31fff3efc1896156647fa5a946b7e60a754342e83205964b31a77ba">HTTP_AUTH_BASIC</a>         },
        { <span class="stringliteral">&quot;digest&quot;</span>,             <a class="code" href="rest_8h.html#ad18ce766db31fff3efc1896156647fa5a2de9030bd220adb7701f5cbdeadfc4a3">HTTP_AUTH_DIGEST</a>        },
        { <span class="stringliteral">&quot;digest-ie&quot;</span>,          <a class="code" href="rest_8h.html#ad18ce766db31fff3efc1896156647fa5a1f0c85c5931f26c607c7e47cf13a2d69">HTTP_AUTH_DIGEST_IE</a>     },
        { <span class="stringliteral">&quot;gss-negotiate&quot;</span>,      <a class="code" href="rest_8h.html#ad18ce766db31fff3efc1896156647fa5a619673a5be376264ae5698ad9709b48a">HTTP_AUTH_GSSNEGOTIATE</a>  },
        { <span class="stringliteral">&quot;ntlm&quot;</span>,               <a class="code" href="rest_8h.html#ad18ce766db31fff3efc1896156647fa5a42fba6486b2a44775f09c0cfb8ac5176">HTTP_AUTH_NTLM</a>          },
        { <span class="stringliteral">&quot;ntlm-winbind&quot;</span>,       <a class="code" href="rest_8h.html#ad18ce766db31fff3efc1896156647fa5a7c399281a3b842ff124c6f916fc82db6">HTTP_AUTH_NTLM_WB</a>       },
        { <span class="stringliteral">&quot;any&quot;</span>,                <a class="code" href="rest_8h.html#ad18ce766db31fff3efc1896156647fa5a4738427f84f848c4e476644bd78a83cc">HTTP_AUTH_ANY</a>           },
        { <span class="stringliteral">&quot;safe&quot;</span>,               <a class="code" href="rest_8h.html#ad18ce766db31fff3efc1896156647fa5afe11e217d1bdaa3d306d3b679d016414">HTTP_AUTH_ANY_SAFE</a>      },

        {  NULL , -1 }
}
</pre></div>
<p>Definition at line <a class="el" href="rest_8c_source.html#l00142">142</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="ab429e4b10850d1e40766e0aa58316c9b"></a><!-- doxytag: member="rest.c::http_body_type_supported" ref="ab429e4b10850d1e40766e0aa58316c9b" args="[HTTP_BODY_NUM_ENTRIES]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43">http_body_type_t</a> <a class="el" href="rest_8h.html#ab429e4b10850d1e40766e0aa58316c9b">http_body_type_supported</a>[HTTP_BODY_NUM_ENTRIES]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43ab099899ce07949ee61322970cff3f453">HTTP_BODY_UNSUPPORTED</a>,  
        <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43ab099899ce07949ee61322970cff3f453">HTTP_BODY_UNSUPPORTED</a>,  
        <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43ab099899ce07949ee61322970cff3f453">HTTP_BODY_UNSUPPORTED</a>,  
        <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43ac6a5a8af942393478386105b35dc80d5">HTTP_BODY_POST</a>,         
        <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43a68c03dcf546a3349f7cdca9cfec7cb08">HTTP_BODY_JSON</a>,         
        <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43ab099899ce07949ee61322970cff3f453">HTTP_BODY_UNSUPPORTED</a>,  
        <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43ab099899ce07949ee61322970cff3f453">HTTP_BODY_UNSUPPORTED</a>,  
        <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43a8a3328b9f8f72b0801e0a36769f74cdb">HTTP_BODY_INVALID</a>,      
        HTTP_BODY_INVALID       
}
</pre></div>
<p>Table of encoder/decoder support. </p>
<p>Indexes in this table match the http_body_type_t enum, and should be updated if additional enum values are added.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43">http_body_type_t</a> </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00048">48</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad34138dc5bcd567ef2c520ef721c8ac2"></a><!-- doxytag: member="rest.c::http_body_type_table" ref="ad34138dc5bcd567ef2c520ef721c8ac2" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structFR__NAME__NUMBER.html">FR_NAME_NUMBER</a> <a class="el" href="rest_8c.html#ad34138dc5bcd567ef2c520ef721c8ac2">http_body_type_table</a>[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        { <span class="stringliteral">&quot;unknown&quot;</span>,            <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43a4a3674c75efd39582b497441acf04d41">HTTP_BODY_UNKNOWN</a>       },
        { <span class="stringliteral">&quot;unsupported&quot;</span>,        <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43ab099899ce07949ee61322970cff3f453">HTTP_BODY_UNSUPPORTED</a>   },
        { <span class="stringliteral">&quot;invalid&quot;</span>,            <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43a8a3328b9f8f72b0801e0a36769f74cdb">HTTP_BODY_INVALID</a>       },
        { <span class="stringliteral">&quot;post&quot;</span>,               <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43ac6a5a8af942393478386105b35dc80d5">HTTP_BODY_POST</a>          },
        { <span class="stringliteral">&quot;json&quot;</span>,               <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43a68c03dcf546a3349f7cdca9cfec7cb08">HTTP_BODY_JSON</a>          },
        { <span class="stringliteral">&quot;xml&quot;</span>,                <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43ad2e34d9f24861c32ac553b6cea746be1">HTTP_BODY_XML</a>           },
        { <span class="stringliteral">&quot;yaml&quot;</span>,               <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43a9364f084a9c76e1c4669757278c6a33c">HTTP_BODY_YAML</a>          },
        { <span class="stringliteral">&quot;html&quot;</span>,               <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43acd89b006f022a89db6f604472a71043d">HTTP_BODY_HTML</a>          },
        { <span class="stringliteral">&quot;plain&quot;</span>,              <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43af18fc16eefbea13657dedc63f8b321a6">HTTP_BODY_PLAIN</a>         },

        {  NULL , -1 }
}
</pre></div>
<p>Conversion table for type config values. </p>
<p>Textual names for http_body_type_t enum values, used by the configuration parser.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>http_body_Type_t </dd>
<dd>
<a class="el" href="token_8c.html#aa79c5188edefb696373a75cee4dc81e3">fr_str2int</a> </dd>
<dd>
<a class="el" href="token_8c.html#ad2f2d09b23cc5a7bc760aacafa278fdd">fr_int2str</a> </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00128">128</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a66f9f5e6959f072ef736c9c2bb86b25b"></a><!-- doxytag: member="rest.c::http_content_type_table" ref="a66f9f5e6959f072ef736c9c2bb86b25b" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structFR__NAME__NUMBER.html">FR_NAME_NUMBER</a> <a class="el" href="rest_8c.html#a66f9f5e6959f072ef736c9c2bb86b25b">http_content_type_table</a>[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        { <span class="stringliteral">&quot;application/x-www-form-urlencoded&quot;</span>, <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43ac6a5a8af942393478386105b35dc80d5">HTTP_BODY_POST</a> },
        { <span class="stringliteral">&quot;application/json&quot;</span>,   <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43a68c03dcf546a3349f7cdca9cfec7cb08">HTTP_BODY_JSON</a>          },
        { <span class="stringliteral">&quot;text/html&quot;</span>,          <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43acd89b006f022a89db6f604472a71043d">HTTP_BODY_HTML</a>          },
        { <span class="stringliteral">&quot;text/plain&quot;</span>,         <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43af18fc16eefbea13657dedc63f8b321a6">HTTP_BODY_PLAIN</a>         },
        { <span class="stringliteral">&quot;text/xml&quot;</span>,           <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43ad2e34d9f24861c32ac553b6cea746be1">HTTP_BODY_XML</a>           },
        { <span class="stringliteral">&quot;text/yaml&quot;</span>,          <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43a9364f084a9c76e1c4669757278c6a33c">HTTP_BODY_YAML</a>          },
        { <span class="stringliteral">&quot;text/x-yaml&quot;</span>,        <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43a9364f084a9c76e1c4669757278c6a33c">HTTP_BODY_YAML</a>          },
        { <span class="stringliteral">&quot;application/yaml&quot;</span>,   <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43a9364f084a9c76e1c4669757278c6a33c">HTTP_BODY_YAML</a>          },
        { <span class="stringliteral">&quot;application/x-yaml&quot;</span>, <a class="code" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43a9364f084a9c76e1c4669757278c6a33c">HTTP_BODY_YAML</a>          },
        {  NULL , -1 }
}
</pre></div>
<p>Conversion table for "Content-Type" header values. </p>
<p>Used by rest_write_header for parsing incoming headers.</p>
<p>Values we expect to see in the 'Content-Type:' header of the incoming response.</p>
<p>Some data types (like YAML) do no have standard MIME types defined, so multiple types, are listed here.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>http_body_Type_t </dd>
<dd>
<a class="el" href="token_8c.html#aa79c5188edefb696373a75cee4dc81e3">fr_str2int</a> </dd>
<dd>
<a class="el" href="token_8c.html#ad2f2d09b23cc5a7bc760aacafa278fdd">fr_int2str</a> </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00171">171</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a464926ec2ef2e24d5b7da3691b8398f6"></a><!-- doxytag: member="rest.c::http_curl_auth" ref="a464926ec2ef2e24d5b7da3691b8398f6" args="[HTTP_AUTH_NUM_ENTRIES]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="rest_8h.html#a3eec2e1ce851fda087b08d05cbd96c43">http_body_type_t</a> <a class="el" href="rest_8h.html#a464926ec2ef2e24d5b7da3691b8398f6">http_curl_auth</a>[HTTP_AUTH_NUM_ENTRIES]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        0,                      
        0,                      
        <a class="code" href="rest_8c.html#a69d79dbb506da186a157096c8cd16a5a">CURLOPT_TLSAUTH_SRP</a>,    
        <a class="code" href="rest_8c.html#a71a1fde704d583a1f5dc57f77f1e957b">CURLAUTH_BASIC</a>,         
        <a class="code" href="rest_8c.html#ae8273f5a281c589c89d0d3ab2f565a93">CURLAUTH_DIGEST</a>,        
        <a class="code" href="rest_8c.html#a35dfbbf1be296636005ebb30f70ca4ee">CURLAUTH_DIGEST_IE</a>,     
        <a class="code" href="rest_8c.html#abd8249802f5605e95c6fedcaf22f9f5c">CURLAUTH_GSSNEGOTIATE</a>,  
        <a class="code" href="rest_8c.html#ab0e8299ededa678028a9e5796b0f77ce">CURLAUTH_NTLM</a>,          
        <a class="code" href="rest_8c.html#abc73006227ef9c2827f26b33d7cbadce">CURLAUTH_NTLM_WB</a>,       
        CURLAUTH_ANY,           
        CURLAUTH_ANYSAFE        
}
</pre></div>
<p>Definition at line <a class="el" href="rest_8c_source.html#l00085">85</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
<a class="anchor" id="a8dc21ec6893fd93311316d23e446347b"></a><!-- doxytag: member="rest.c::http_method_table" ref="a8dc21ec6893fd93311316d23e446347b" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structFR__NAME__NUMBER.html">FR_NAME_NUMBER</a> <a class="el" href="rest_8h.html#a8dc21ec6893fd93311316d23e446347b">http_method_table</a>[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        { <span class="stringliteral">&quot;GET&quot;</span>,                <a class="code" href="rest_8h.html#a2fd930fba66817097e73ba9b75800eb2a90754abc55dbb76862fa50abee5af659">HTTP_METHOD_GET</a>         },
        { <span class="stringliteral">&quot;POST&quot;</span>,               <a class="code" href="rest_8h.html#a2fd930fba66817097e73ba9b75800eb2a1944682922ac79b2e682312d8f3f71e2">HTTP_METHOD_POST</a>        },
        { <span class="stringliteral">&quot;PUT&quot;</span>,                <a class="code" href="rest_8h.html#a2fd930fba66817097e73ba9b75800eb2af7557927b605c64f35f629b43823b1c9">HTTP_METHOD_PUT</a>         },
        { <span class="stringliteral">&quot;DELETE&quot;</span>,             <a class="code" href="rest_8h.html#a2fd930fba66817097e73ba9b75800eb2a761371f7807255b7912afbac2f665ffe">HTTP_METHOD_DELETE</a>      },

        {  NULL , -1 }
}
</pre></div>
<p>Conversion table for method config values. </p>
<p>HTTP verb strings for http_method_t enum values. Used by libcurl in the status line of the outgoing HTTP header, by rest_write_header for decoding incoming HTTP responses, and by the configuration parser.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rest_8h.html#a2fd930fba66817097e73ba9b75800eb2">http_method_t</a> </dd>
<dd>
<a class="el" href="token_8c.html#aa79c5188edefb696373a75cee4dc81e3">fr_str2int</a> </dd>
<dd>
<a class="el" href="token_8c.html#ad2f2d09b23cc5a7bc760aacafa278fdd">fr_int2str</a> </dd></dl>

<p>Definition at line <a class="el" href="rest_8c_source.html#l00110">110</a> of file <a class="el" href="rest_8c_source.html">rest.c</a>.</p>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 5 2012 16:31:06 for FreeRADIUS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5
</small></address>

</body>
</html>
